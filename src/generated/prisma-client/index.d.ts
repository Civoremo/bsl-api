// Code generated by Prisma (prisma@1.31.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  game: (where?: GameWhereInput) => Promise<boolean>;
  league: (where?: LeagueWhereInput) => Promise<boolean>;
  loss: (where?: LossWhereInput) => Promise<boolean>;
  player: (where?: PlayerWhereInput) => Promise<boolean>;
  team: (where?: TeamWhereInput) => Promise<boolean>;
  tie: (where?: TieWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  win: (where?: WinWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  game: (where: GameWhereUniqueInput) => GamePromise;
  games: (args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Game>;
  gamesConnection: (args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GameConnectionPromise;
  league: (where: LeagueWhereUniqueInput) => LeaguePromise;
  leagues: (args?: {
    where?: LeagueWhereInput;
    orderBy?: LeagueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<League>;
  leaguesConnection: (args?: {
    where?: LeagueWhereInput;
    orderBy?: LeagueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LeagueConnectionPromise;
  loss: (where: LossWhereUniqueInput) => LossPromise;
  losses: (args?: {
    where?: LossWhereInput;
    orderBy?: LossOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Loss>;
  lossesConnection: (args?: {
    where?: LossWhereInput;
    orderBy?: LossOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LossConnectionPromise;
  player: (where: PlayerWhereUniqueInput) => PlayerPromise;
  players: (args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Player>;
  playersConnection: (args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlayerConnectionPromise;
  team: (where: TeamWhereUniqueInput) => TeamPromise;
  teams: (args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Team>;
  teamsConnection: (args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TeamConnectionPromise;
  tie: (where: TieWhereUniqueInput) => TiePromise;
  ties: (args?: {
    where?: TieWhereInput;
    orderBy?: TieOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tie>;
  tiesConnection: (args?: {
    where?: TieWhereInput;
    orderBy?: TieOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TieConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  win: (where: WinWhereUniqueInput) => WinPromise;
  wins: (args?: {
    where?: WinWhereInput;
    orderBy?: WinOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Win>;
  winsConnection: (args?: {
    where?: WinWhereInput;
    orderBy?: WinOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WinConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createGame: (data: GameCreateInput) => GamePromise;
  updateGame: (args: {
    data: GameUpdateInput;
    where: GameWhereUniqueInput;
  }) => GamePromise;
  updateManyGames: (args: {
    data: GameUpdateManyMutationInput;
    where?: GameWhereInput;
  }) => BatchPayloadPromise;
  upsertGame: (args: {
    where: GameWhereUniqueInput;
    create: GameCreateInput;
    update: GameUpdateInput;
  }) => GamePromise;
  deleteGame: (where: GameWhereUniqueInput) => GamePromise;
  deleteManyGames: (where?: GameWhereInput) => BatchPayloadPromise;
  createLeague: (data: LeagueCreateInput) => LeaguePromise;
  updateLeague: (args: {
    data: LeagueUpdateInput;
    where: LeagueWhereUniqueInput;
  }) => LeaguePromise;
  updateManyLeagues: (args: {
    data: LeagueUpdateManyMutationInput;
    where?: LeagueWhereInput;
  }) => BatchPayloadPromise;
  upsertLeague: (args: {
    where: LeagueWhereUniqueInput;
    create: LeagueCreateInput;
    update: LeagueUpdateInput;
  }) => LeaguePromise;
  deleteLeague: (where: LeagueWhereUniqueInput) => LeaguePromise;
  deleteManyLeagues: (where?: LeagueWhereInput) => BatchPayloadPromise;
  createLoss: (data: LossCreateInput) => LossPromise;
  updateLoss: (args: {
    data: LossUpdateInput;
    where: LossWhereUniqueInput;
  }) => LossPromise;
  upsertLoss: (args: {
    where: LossWhereUniqueInput;
    create: LossCreateInput;
    update: LossUpdateInput;
  }) => LossPromise;
  deleteLoss: (where: LossWhereUniqueInput) => LossPromise;
  deleteManyLosses: (where?: LossWhereInput) => BatchPayloadPromise;
  createPlayer: (data: PlayerCreateInput) => PlayerPromise;
  updatePlayer: (args: {
    data: PlayerUpdateInput;
    where: PlayerWhereUniqueInput;
  }) => PlayerPromise;
  updateManyPlayers: (args: {
    data: PlayerUpdateManyMutationInput;
    where?: PlayerWhereInput;
  }) => BatchPayloadPromise;
  upsertPlayer: (args: {
    where: PlayerWhereUniqueInput;
    create: PlayerCreateInput;
    update: PlayerUpdateInput;
  }) => PlayerPromise;
  deletePlayer: (where: PlayerWhereUniqueInput) => PlayerPromise;
  deleteManyPlayers: (where?: PlayerWhereInput) => BatchPayloadPromise;
  createTeam: (data: TeamCreateInput) => TeamPromise;
  updateTeam: (args: {
    data: TeamUpdateInput;
    where: TeamWhereUniqueInput;
  }) => TeamPromise;
  updateManyTeams: (args: {
    data: TeamUpdateManyMutationInput;
    where?: TeamWhereInput;
  }) => BatchPayloadPromise;
  upsertTeam: (args: {
    where: TeamWhereUniqueInput;
    create: TeamCreateInput;
    update: TeamUpdateInput;
  }) => TeamPromise;
  deleteTeam: (where: TeamWhereUniqueInput) => TeamPromise;
  deleteManyTeams: (where?: TeamWhereInput) => BatchPayloadPromise;
  createTie: (data: TieCreateInput) => TiePromise;
  updateTie: (args: {
    data: TieUpdateInput;
    where: TieWhereUniqueInput;
  }) => TiePromise;
  upsertTie: (args: {
    where: TieWhereUniqueInput;
    create: TieCreateInput;
    update: TieUpdateInput;
  }) => TiePromise;
  deleteTie: (where: TieWhereUniqueInput) => TiePromise;
  deleteManyTies: (where?: TieWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createWin: (data: WinCreateInput) => WinPromise;
  updateWin: (args: {
    data: WinUpdateInput;
    where: WinWhereUniqueInput;
  }) => WinPromise;
  upsertWin: (args: {
    where: WinWhereUniqueInput;
    create: WinCreateInput;
    update: WinUpdateInput;
  }) => WinPromise;
  deleteWin: (where: WinWhereUniqueInput) => WinPromise;
  deleteManyWins: (where?: WinWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  game: (
    where?: GameSubscriptionWhereInput
  ) => GameSubscriptionPayloadSubscription;
  league: (
    where?: LeagueSubscriptionWhereInput
  ) => LeagueSubscriptionPayloadSubscription;
  loss: (
    where?: LossSubscriptionWhereInput
  ) => LossSubscriptionPayloadSubscription;
  player: (
    where?: PlayerSubscriptionWhereInput
  ) => PlayerSubscriptionPayloadSubscription;
  team: (
    where?: TeamSubscriptionWhereInput
  ) => TeamSubscriptionPayloadSubscription;
  tie: (
    where?: TieSubscriptionWhereInput
  ) => TieSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  win: (
    where?: WinSubscriptionWhereInput
  ) => WinSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Role = "SUPERADMIN" | "ADMIN" | "PLAYER" | "USER";

export type LeagueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "location_ASC"
  | "location_DESC";

export type TeamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type WinOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LossOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TieOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type PlayerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "played_ASC"
  | "played_DESC"
  | "goals_ASC"
  | "goals_DESC"
  | "assists_ASC"
  | "assists_DESC"
  | "saves_ASC"
  | "saves_DESC";

export type GameOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "score_ASC"
  | "score_DESC"
  | "day_ASC"
  | "day_DESC"
  | "time_ASC"
  | "time_DESC"
  | "videoURL_ASC"
  | "videoURL_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "password_ASC"
  | "password_DESC"
  | "email_ASC"
  | "email_DESC"
  | "role_ASC"
  | "role_DESC";

export interface UserUpdateDataInput {
  name?: String;
  password?: String;
  email?: String;
  role?: Role;
  leagues?: LeagueUpdateManyWithoutPostedByInput;
  teams?: TeamUpdateManyWithoutPostedByInput;
  players?: PlayerUpdateManyWithoutPostedByInput;
  games?: GameUpdateManyWithoutPostedByInput;
}

export type GameWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface LossUpdateWithoutTeamDataInput {
  postedBy?: UserUpdateOneRequiredInput;
  game?: GameUpdateOneRequiredInput;
}

export interface LossWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  postedBy?: UserWhereInput;
  team?: TeamWhereInput;
  game?: GameWhereInput;
  AND?: LossWhereInput[] | LossWhereInput;
  OR?: LossWhereInput[] | LossWhereInput;
  NOT?: LossWhereInput[] | LossWhereInput;
}

export interface GameUpdateOneRequiredInput {
  create?: GameCreateInput;
  update?: GameUpdateDataInput;
  upsert?: GameUpsertNestedInput;
  connect?: GameWhereUniqueInput;
}

export interface PlayerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  postedBy?: UserWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  played?: Int;
  played_not?: Int;
  played_in?: Int[] | Int;
  played_not_in?: Int[] | Int;
  played_lt?: Int;
  played_lte?: Int;
  played_gt?: Int;
  played_gte?: Int;
  goals?: Int;
  goals_not?: Int;
  goals_in?: Int[] | Int;
  goals_not_in?: Int[] | Int;
  goals_lt?: Int;
  goals_lte?: Int;
  goals_gt?: Int;
  goals_gte?: Int;
  assists?: Int;
  assists_not?: Int;
  assists_in?: Int[] | Int;
  assists_not_in?: Int[] | Int;
  assists_lt?: Int;
  assists_lte?: Int;
  assists_gt?: Int;
  assists_gte?: Int;
  saves?: Int;
  saves_not?: Int;
  saves_in?: Int[] | Int;
  saves_not_in?: Int[] | Int;
  saves_lt?: Int;
  saves_lte?: Int;
  saves_gt?: Int;
  saves_gte?: Int;
  team?: TeamWhereInput;
  AND?: PlayerWhereInput[] | PlayerWhereInput;
  OR?: PlayerWhereInput[] | PlayerWhereInput;
  NOT?: PlayerWhereInput[] | PlayerWhereInput;
}

export interface GameUpdateDataInput {
  postedBy?: UserUpdateOneRequiredWithoutGamesInput;
  homeTeam?: TeamUpdateOneRequiredInput;
  awayTeam?: TeamUpdateOneRequiredInput;
  score?: String;
  day?: String;
  time?: String;
  videoURL?: String;
  league?: LeagueUpdateOneRequiredWithoutGamesInput;
}

export interface GameWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  postedBy?: UserWhereInput;
  homeTeam?: TeamWhereInput;
  awayTeam?: TeamWhereInput;
  score?: String;
  score_not?: String;
  score_in?: String[] | String;
  score_not_in?: String[] | String;
  score_lt?: String;
  score_lte?: String;
  score_gt?: String;
  score_gte?: String;
  score_contains?: String;
  score_not_contains?: String;
  score_starts_with?: String;
  score_not_starts_with?: String;
  score_ends_with?: String;
  score_not_ends_with?: String;
  day?: String;
  day_not?: String;
  day_in?: String[] | String;
  day_not_in?: String[] | String;
  day_lt?: String;
  day_lte?: String;
  day_gt?: String;
  day_gte?: String;
  day_contains?: String;
  day_not_contains?: String;
  day_starts_with?: String;
  day_not_starts_with?: String;
  day_ends_with?: String;
  day_not_ends_with?: String;
  time?: String;
  time_not?: String;
  time_in?: String[] | String;
  time_not_in?: String[] | String;
  time_lt?: String;
  time_lte?: String;
  time_gt?: String;
  time_gte?: String;
  time_contains?: String;
  time_not_contains?: String;
  time_starts_with?: String;
  time_not_starts_with?: String;
  time_ends_with?: String;
  time_not_ends_with?: String;
  videoURL?: String;
  videoURL_not?: String;
  videoURL_in?: String[] | String;
  videoURL_not_in?: String[] | String;
  videoURL_lt?: String;
  videoURL_lte?: String;
  videoURL_gt?: String;
  videoURL_gte?: String;
  videoURL_contains?: String;
  videoURL_not_contains?: String;
  videoURL_starts_with?: String;
  videoURL_not_starts_with?: String;
  videoURL_ends_with?: String;
  videoURL_not_ends_with?: String;
  league?: LeagueWhereInput;
  AND?: GameWhereInput[] | GameWhereInput;
  OR?: GameWhereInput[] | GameWhereInput;
  NOT?: GameWhereInput[] | GameWhereInput;
}

export interface TeamUpdateOneRequiredInput {
  create?: TeamCreateInput;
  update?: TeamUpdateDataInput;
  upsert?: TeamUpsertNestedInput;
  connect?: TeamWhereUniqueInput;
}

export interface WinWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  postedBy?: UserWhereInput;
  team?: TeamWhereInput;
  game?: GameWhereInput;
  AND?: WinWhereInput[] | WinWhereInput;
  OR?: WinWhereInput[] | WinWhereInput;
  NOT?: WinWhereInput[] | WinWhereInput;
}

export interface TeamUpdateDataInput {
  postedBy?: UserUpdateOneRequiredWithoutTeamsInput;
  name?: String;
  wins?: WinUpdateManyWithoutTeamInput;
  losses?: LossUpdateManyWithoutTeamInput;
  ties?: TieUpdateManyWithoutTeamInput;
  league?: LeagueUpdateOneRequiredWithoutTeamsInput;
  players?: PlayerUpdateManyWithoutTeamInput;
}

export interface TeamWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  postedBy?: UserWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  wins_every?: WinWhereInput;
  wins_some?: WinWhereInput;
  wins_none?: WinWhereInput;
  losses_every?: LossWhereInput;
  losses_some?: LossWhereInput;
  losses_none?: LossWhereInput;
  ties_every?: TieWhereInput;
  ties_some?: TieWhereInput;
  ties_none?: TieWhereInput;
  league?: LeagueWhereInput;
  players_every?: PlayerWhereInput;
  players_some?: PlayerWhereInput;
  players_none?: PlayerWhereInput;
  AND?: TeamWhereInput[] | TeamWhereInput;
  OR?: TeamWhereInput[] | TeamWhereInput;
  NOT?: TeamWhereInput[] | TeamWhereInput;
}

export interface TieUpdateManyWithoutTeamInput {
  create?: TieCreateWithoutTeamInput[] | TieCreateWithoutTeamInput;
  delete?: TieWhereUniqueInput[] | TieWhereUniqueInput;
  connect?: TieWhereUniqueInput[] | TieWhereUniqueInput;
  set?: TieWhereUniqueInput[] | TieWhereUniqueInput;
  disconnect?: TieWhereUniqueInput[] | TieWhereUniqueInput;
  update?:
    | TieUpdateWithWhereUniqueWithoutTeamInput[]
    | TieUpdateWithWhereUniqueWithoutTeamInput;
  upsert?:
    | TieUpsertWithWhereUniqueWithoutTeamInput[]
    | TieUpsertWithWhereUniqueWithoutTeamInput;
  deleteMany?: TieScalarWhereInput[] | TieScalarWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  role?: Role;
  role_not?: Role;
  role_in?: Role[] | Role;
  role_not_in?: Role[] | Role;
  leagues_every?: LeagueWhereInput;
  leagues_some?: LeagueWhereInput;
  leagues_none?: LeagueWhereInput;
  teams_every?: TeamWhereInput;
  teams_some?: TeamWhereInput;
  teams_none?: TeamWhereInput;
  players_every?: PlayerWhereInput;
  players_some?: PlayerWhereInput;
  players_none?: PlayerWhereInput;
  games_every?: GameWhereInput;
  games_some?: GameWhereInput;
  games_none?: GameWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface TieUpdateWithWhereUniqueWithoutTeamInput {
  where: TieWhereUniqueInput;
  data: TieUpdateWithoutTeamDataInput;
}

export interface LeagueWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  postedBy?: UserWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  teams_every?: TeamWhereInput;
  teams_some?: TeamWhereInput;
  teams_none?: TeamWhereInput;
  location?: String;
  location_not?: String;
  location_in?: String[] | String;
  location_not_in?: String[] | String;
  location_lt?: String;
  location_lte?: String;
  location_gt?: String;
  location_gte?: String;
  location_contains?: String;
  location_not_contains?: String;
  location_starts_with?: String;
  location_not_starts_with?: String;
  location_ends_with?: String;
  location_not_ends_with?: String;
  games_every?: GameWhereInput;
  games_some?: GameWhereInput;
  games_none?: GameWhereInput;
  AND?: LeagueWhereInput[] | LeagueWhereInput;
  OR?: LeagueWhereInput[] | LeagueWhereInput;
  NOT?: LeagueWhereInput[] | LeagueWhereInput;
}

export interface TeamUpdateManyWithoutLeagueInput {
  create?: TeamCreateWithoutLeagueInput[] | TeamCreateWithoutLeagueInput;
  delete?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  set?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  disconnect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  update?:
    | TeamUpdateWithWhereUniqueWithoutLeagueInput[]
    | TeamUpdateWithWhereUniqueWithoutLeagueInput;
  upsert?:
    | TeamUpsertWithWhereUniqueWithoutLeagueInput[]
    | TeamUpsertWithWhereUniqueWithoutLeagueInput;
  deleteMany?: TeamScalarWhereInput[] | TeamScalarWhereInput;
  updateMany?:
    | TeamUpdateManyWithWhereNestedInput[]
    | TeamUpdateManyWithWhereNestedInput;
}

export interface LeagueCreateInput {
  id?: ID_Input;
  postedBy: UserCreateOneWithoutLeaguesInput;
  name: String;
  teams?: TeamCreateManyWithoutLeagueInput;
  location: String;
  games?: GameCreateManyWithoutLeagueInput;
}

export interface TeamUpdateWithWhereUniqueWithoutLeagueInput {
  where: TeamWhereUniqueInput;
  data: TeamUpdateWithoutLeagueDataInput;
}

export interface TieUpdateWithoutTeamDataInput {
  postedBy?: UserUpdateOneRequiredInput;
  game?: GameUpdateOneRequiredInput;
}

export interface TeamUpdateWithoutLeagueDataInput {
  postedBy?: UserUpdateOneRequiredWithoutTeamsInput;
  name?: String;
  wins?: WinUpdateManyWithoutTeamInput;
  losses?: LossUpdateManyWithoutTeamInput;
  ties?: TieUpdateManyWithoutTeamInput;
  players?: PlayerUpdateManyWithoutTeamInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface UserUpdateOneRequiredWithoutTeamsInput {
  create?: UserCreateWithoutTeamsInput;
  update?: UserUpdateWithoutTeamsDataInput;
  upsert?: UserUpsertWithoutTeamsInput;
  connect?: UserWhereUniqueInput;
}

export interface TeamSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TeamWhereInput;
  AND?: TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput;
  OR?: TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput;
  NOT?: TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput;
}

export interface UserUpdateWithoutTeamsDataInput {
  name?: String;
  password?: String;
  email?: String;
  role?: Role;
  leagues?: LeagueUpdateManyWithoutPostedByInput;
  players?: PlayerUpdateManyWithoutPostedByInput;
  games?: GameUpdateManyWithoutPostedByInput;
}

export interface LossSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LossWhereInput;
  AND?: LossSubscriptionWhereInput[] | LossSubscriptionWhereInput;
  OR?: LossSubscriptionWhereInput[] | LossSubscriptionWhereInput;
  NOT?: LossSubscriptionWhereInput[] | LossSubscriptionWhereInput;
}

export interface PlayerUpdateManyWithoutPostedByInput {
  create?:
    | PlayerCreateWithoutPostedByInput[]
    | PlayerCreateWithoutPostedByInput;
  delete?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  connect?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  set?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  disconnect?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  update?:
    | PlayerUpdateWithWhereUniqueWithoutPostedByInput[]
    | PlayerUpdateWithWhereUniqueWithoutPostedByInput;
  upsert?:
    | PlayerUpsertWithWhereUniqueWithoutPostedByInput[]
    | PlayerUpsertWithWhereUniqueWithoutPostedByInput;
  deleteMany?: PlayerScalarWhereInput[] | PlayerScalarWhereInput;
  updateMany?:
    | PlayerUpdateManyWithWhereNestedInput[]
    | PlayerUpdateManyWithWhereNestedInput;
}

export interface LeagueSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LeagueWhereInput;
  AND?: LeagueSubscriptionWhereInput[] | LeagueSubscriptionWhereInput;
  OR?: LeagueSubscriptionWhereInput[] | LeagueSubscriptionWhereInput;
  NOT?: LeagueSubscriptionWhereInput[] | LeagueSubscriptionWhereInput;
}

export interface PlayerUpdateWithWhereUniqueWithoutPostedByInput {
  where: PlayerWhereUniqueInput;
  data: PlayerUpdateWithoutPostedByDataInput;
}

export interface TeamUpsertWithoutWinsInput {
  update: TeamUpdateWithoutWinsDataInput;
  create: TeamCreateWithoutWinsInput;
}

export interface PlayerUpdateWithoutPostedByDataInput {
  name?: String;
  played?: Int;
  goals?: Int;
  assists?: Int;
  saves?: Int;
  team?: TeamUpdateOneRequiredWithoutPlayersInput;
}

export interface TeamUpdateWithoutWinsDataInput {
  postedBy?: UserUpdateOneRequiredWithoutTeamsInput;
  name?: String;
  losses?: LossUpdateManyWithoutTeamInput;
  ties?: TieUpdateManyWithoutTeamInput;
  league?: LeagueUpdateOneRequiredWithoutTeamsInput;
  players?: PlayerUpdateManyWithoutTeamInput;
}

export interface TeamUpdateOneRequiredWithoutPlayersInput {
  create?: TeamCreateWithoutPlayersInput;
  update?: TeamUpdateWithoutPlayersDataInput;
  upsert?: TeamUpsertWithoutPlayersInput;
  connect?: TeamWhereUniqueInput;
}

export interface WinUpdateInput {
  postedBy?: UserUpdateOneRequiredInput;
  team?: TeamUpdateOneRequiredWithoutWinsInput;
  game?: GameUpdateOneRequiredInput;
}

export interface TeamUpdateWithoutPlayersDataInput {
  postedBy?: UserUpdateOneRequiredWithoutTeamsInput;
  name?: String;
  wins?: WinUpdateManyWithoutTeamInput;
  losses?: LossUpdateManyWithoutTeamInput;
  ties?: TieUpdateManyWithoutTeamInput;
  league?: LeagueUpdateOneRequiredWithoutTeamsInput;
}

export interface TeamCreateWithoutWinsInput {
  id?: ID_Input;
  postedBy: UserCreateOneWithoutTeamsInput;
  name: String;
  losses?: LossCreateManyWithoutTeamInput;
  ties?: TieCreateManyWithoutTeamInput;
  league: LeagueCreateOneWithoutTeamsInput;
  players?: PlayerCreateManyWithoutTeamInput;
}

export interface WinUpdateManyWithoutTeamInput {
  create?: WinCreateWithoutTeamInput[] | WinCreateWithoutTeamInput;
  delete?: WinWhereUniqueInput[] | WinWhereUniqueInput;
  connect?: WinWhereUniqueInput[] | WinWhereUniqueInput;
  set?: WinWhereUniqueInput[] | WinWhereUniqueInput;
  disconnect?: WinWhereUniqueInput[] | WinWhereUniqueInput;
  update?:
    | WinUpdateWithWhereUniqueWithoutTeamInput[]
    | WinUpdateWithWhereUniqueWithoutTeamInput;
  upsert?:
    | WinUpsertWithWhereUniqueWithoutTeamInput[]
    | WinUpsertWithWhereUniqueWithoutTeamInput;
  deleteMany?: WinScalarWhereInput[] | WinScalarWhereInput;
}

export interface WinCreateInput {
  id?: ID_Input;
  postedBy: UserCreateOneInput;
  team: TeamCreateOneWithoutWinsInput;
  game: GameCreateOneInput;
}

export interface WinUpdateWithWhereUniqueWithoutTeamInput {
  where: WinWhereUniqueInput;
  data: WinUpdateWithoutTeamDataInput;
}

export interface UserUpdateManyMutationInput {
  name?: String;
  password?: String;
  email?: String;
  role?: Role;
}

export interface WinUpdateWithoutTeamDataInput {
  postedBy?: UserUpdateOneRequiredInput;
  game?: GameUpdateOneRequiredInput;
}

export interface TeamUpsertWithoutTiesInput {
  update: TeamUpdateWithoutTiesDataInput;
  create: TeamCreateWithoutTiesInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface TeamUpdateWithoutTiesDataInput {
  postedBy?: UserUpdateOneRequiredWithoutTeamsInput;
  name?: String;
  wins?: WinUpdateManyWithoutTeamInput;
  losses?: LossUpdateManyWithoutTeamInput;
  league?: LeagueUpdateOneRequiredWithoutTeamsInput;
  players?: PlayerUpdateManyWithoutTeamInput;
}

export interface PlayerCreateInput {
  id?: ID_Input;
  postedBy: UserCreateOneWithoutPlayersInput;
  name: String;
  played?: Int;
  goals?: Int;
  assists?: Int;
  saves?: Int;
  team: TeamCreateOneWithoutPlayersInput;
}

export interface TieUpdateInput {
  postedBy?: UserUpdateOneRequiredInput;
  team?: TeamUpdateOneRequiredWithoutTiesInput;
  game?: GameUpdateOneRequiredInput;
}

export interface TeamUpdateManyWithoutPostedByInput {
  create?: TeamCreateWithoutPostedByInput[] | TeamCreateWithoutPostedByInput;
  delete?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  set?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  disconnect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  update?:
    | TeamUpdateWithWhereUniqueWithoutPostedByInput[]
    | TeamUpdateWithWhereUniqueWithoutPostedByInput;
  upsert?:
    | TeamUpsertWithWhereUniqueWithoutPostedByInput[]
    | TeamUpsertWithWhereUniqueWithoutPostedByInput;
  deleteMany?: TeamScalarWhereInput[] | TeamScalarWhereInput;
  updateMany?:
    | TeamUpdateManyWithWhereNestedInput[]
    | TeamUpdateManyWithWhereNestedInput;
}

export interface TeamCreateWithoutTiesInput {
  id?: ID_Input;
  postedBy: UserCreateOneWithoutTeamsInput;
  name: String;
  wins?: WinCreateManyWithoutTeamInput;
  losses?: LossCreateManyWithoutTeamInput;
  league: LeagueCreateOneWithoutTeamsInput;
  players?: PlayerCreateManyWithoutTeamInput;
}

export interface TeamUpdateWithWhereUniqueWithoutPostedByInput {
  where: TeamWhereUniqueInput;
  data: TeamUpdateWithoutPostedByDataInput;
}

export interface TieCreateInput {
  id?: ID_Input;
  postedBy: UserCreateOneInput;
  team: TeamCreateOneWithoutTiesInput;
  game: GameCreateOneInput;
}

export interface TeamUpdateWithoutPostedByDataInput {
  name?: String;
  wins?: WinUpdateManyWithoutTeamInput;
  losses?: LossUpdateManyWithoutTeamInput;
  ties?: TieUpdateManyWithoutTeamInput;
  league?: LeagueUpdateOneRequiredWithoutTeamsInput;
  players?: PlayerUpdateManyWithoutTeamInput;
}

export type WinWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface LossUpdateManyWithoutTeamInput {
  create?: LossCreateWithoutTeamInput[] | LossCreateWithoutTeamInput;
  delete?: LossWhereUniqueInput[] | LossWhereUniqueInput;
  connect?: LossWhereUniqueInput[] | LossWhereUniqueInput;
  set?: LossWhereUniqueInput[] | LossWhereUniqueInput;
  disconnect?: LossWhereUniqueInput[] | LossWhereUniqueInput;
  update?:
    | LossUpdateWithWhereUniqueWithoutTeamInput[]
    | LossUpdateWithWhereUniqueWithoutTeamInput;
  upsert?:
    | LossUpsertWithWhereUniqueWithoutTeamInput[]
    | LossUpsertWithWhereUniqueWithoutTeamInput;
  deleteMany?: LossScalarWhereInput[] | LossScalarWhereInput;
}

export interface PlayerUpdateManyMutationInput {
  name?: String;
  played?: Int;
  goals?: Int;
  assists?: Int;
  saves?: Int;
}

export interface LossUpdateWithWhereUniqueWithoutTeamInput {
  where: LossWhereUniqueInput;
  data: LossUpdateWithoutTeamDataInput;
}

export interface UserCreateOneWithoutGamesInput {
  create?: UserCreateWithoutGamesInput;
  connect?: UserWhereUniqueInput;
}

export interface TieWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  postedBy?: UserWhereInput;
  team?: TeamWhereInput;
  game?: GameWhereInput;
  AND?: TieWhereInput[] | TieWhereInput;
  OR?: TieWhereInput[] | TieWhereInput;
  NOT?: TieWhereInput[] | TieWhereInput;
}

export interface LeagueCreateManyWithoutPostedByInput {
  create?:
    | LeagueCreateWithoutPostedByInput[]
    | LeagueCreateWithoutPostedByInput;
  connect?: LeagueWhereUniqueInput[] | LeagueWhereUniqueInput;
}

export interface TeamUpsertWithoutLossesInput {
  update: TeamUpdateWithoutLossesDataInput;
  create: TeamCreateWithoutLossesInput;
}

export interface TeamCreateManyWithoutLeagueInput {
  create?: TeamCreateWithoutLeagueInput[] | TeamCreateWithoutLeagueInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
}

export interface TeamUpdateWithoutLossesDataInput {
  postedBy?: UserUpdateOneRequiredWithoutTeamsInput;
  name?: String;
  wins?: WinUpdateManyWithoutTeamInput;
  ties?: TieUpdateManyWithoutTeamInput;
  league?: LeagueUpdateOneRequiredWithoutTeamsInput;
  players?: PlayerUpdateManyWithoutTeamInput;
}

export interface UserCreateOneWithoutTeamsInput {
  create?: UserCreateWithoutTeamsInput;
  connect?: UserWhereUniqueInput;
}

export interface TeamUpdateOneRequiredWithoutLossesInput {
  create?: TeamCreateWithoutLossesInput;
  update?: TeamUpdateWithoutLossesDataInput;
  upsert?: TeamUpsertWithoutLossesInput;
  connect?: TeamWhereUniqueInput;
}

export interface PlayerCreateManyWithoutPostedByInput {
  create?:
    | PlayerCreateWithoutPostedByInput[]
    | PlayerCreateWithoutPostedByInput;
  connect?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
}

export interface LossUpdateInput {
  postedBy?: UserUpdateOneRequiredInput;
  team?: TeamUpdateOneRequiredWithoutLossesInput;
  game?: GameUpdateOneRequiredInput;
}

export interface TeamCreateOneWithoutPlayersInput {
  create?: TeamCreateWithoutPlayersInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamCreateWithoutLossesInput {
  id?: ID_Input;
  postedBy: UserCreateOneWithoutTeamsInput;
  name: String;
  wins?: WinCreateManyWithoutTeamInput;
  ties?: TieCreateManyWithoutTeamInput;
  league: LeagueCreateOneWithoutTeamsInput;
  players?: PlayerCreateManyWithoutTeamInput;
}

export interface WinCreateManyWithoutTeamInput {
  create?: WinCreateWithoutTeamInput[] | WinCreateWithoutTeamInput;
  connect?: WinWhereUniqueInput[] | WinWhereUniqueInput;
}

export interface TeamCreateOneWithoutLossesInput {
  create?: TeamCreateWithoutLossesInput;
  connect?: TeamWhereUniqueInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface LossCreateInput {
  id?: ID_Input;
  postedBy: UserCreateOneInput;
  team: TeamCreateOneWithoutLossesInput;
  game: GameCreateOneInput;
}

export interface TeamCreateManyWithoutPostedByInput {
  create?: TeamCreateWithoutPostedByInput[] | TeamCreateWithoutPostedByInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
}

export interface TieUpsertWithWhereUniqueWithoutTeamInput {
  where: TieWhereUniqueInput;
  update: TieUpdateWithoutTeamDataInput;
  create: TieCreateWithoutTeamInput;
}

export interface LossCreateManyWithoutTeamInput {
  create?: LossCreateWithoutTeamInput[] | LossCreateWithoutTeamInput;
  connect?: LossWhereUniqueInput[] | LossWhereUniqueInput;
}

export interface TieScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: TieScalarWhereInput[] | TieScalarWhereInput;
  OR?: TieScalarWhereInput[] | TieScalarWhereInput;
  NOT?: TieScalarWhereInput[] | TieScalarWhereInput;
}

export interface GameCreateOneInput {
  create?: GameCreateInput;
  connect?: GameWhereUniqueInput;
}

export interface LeagueUpdateOneRequiredWithoutTeamsInput {
  create?: LeagueCreateWithoutTeamsInput;
  update?: LeagueUpdateWithoutTeamsDataInput;
  upsert?: LeagueUpsertWithoutTeamsInput;
  connect?: LeagueWhereUniqueInput;
}

export interface TieCreateWithoutTeamInput {
  id?: ID_Input;
  postedBy: UserCreateOneInput;
  game: GameCreateOneInput;
}

export interface LeagueUpdateWithoutTeamsDataInput {
  postedBy?: UserUpdateOneRequiredWithoutLeaguesInput;
  name?: String;
  location?: String;
  games?: GameUpdateManyWithoutLeagueInput;
}

export interface LeagueCreateWithoutTeamsInput {
  id?: ID_Input;
  postedBy: UserCreateOneWithoutLeaguesInput;
  name: String;
  location: String;
  games?: GameCreateManyWithoutLeagueInput;
}

export interface UserUpdateOneRequiredWithoutLeaguesInput {
  create?: UserCreateWithoutLeaguesInput;
  update?: UserUpdateWithoutLeaguesDataInput;
  upsert?: UserUpsertWithoutLeaguesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutLeaguesInput {
  id?: ID_Input;
  name: String;
  password: String;
  email: String;
  role?: Role;
  teams?: TeamCreateManyWithoutPostedByInput;
  players?: PlayerCreateManyWithoutPostedByInput;
  games?: GameCreateManyWithoutPostedByInput;
}

export interface UserUpdateWithoutLeaguesDataInput {
  name?: String;
  password?: String;
  email?: String;
  role?: Role;
  teams?: TeamUpdateManyWithoutPostedByInput;
  players?: PlayerUpdateManyWithoutPostedByInput;
  games?: GameUpdateManyWithoutPostedByInput;
}

export interface GameCreateWithoutPostedByInput {
  id?: ID_Input;
  homeTeam: TeamCreateOneInput;
  awayTeam: TeamCreateOneInput;
  score?: String;
  day: String;
  time?: String;
  videoURL?: String;
  league: LeagueCreateOneWithoutGamesInput;
}

export interface GameUpdateManyWithoutPostedByInput {
  create?: GameCreateWithoutPostedByInput[] | GameCreateWithoutPostedByInput;
  delete?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  connect?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  set?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  disconnect?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  update?:
    | GameUpdateWithWhereUniqueWithoutPostedByInput[]
    | GameUpdateWithWhereUniqueWithoutPostedByInput;
  upsert?:
    | GameUpsertWithWhereUniqueWithoutPostedByInput[]
    | GameUpsertWithWhereUniqueWithoutPostedByInput;
  deleteMany?: GameScalarWhereInput[] | GameScalarWhereInput;
  updateMany?:
    | GameUpdateManyWithWhereNestedInput[]
    | GameUpdateManyWithWhereNestedInput;
}

export interface TeamCreateInput {
  id?: ID_Input;
  postedBy: UserCreateOneWithoutTeamsInput;
  name: String;
  wins?: WinCreateManyWithoutTeamInput;
  losses?: LossCreateManyWithoutTeamInput;
  ties?: TieCreateManyWithoutTeamInput;
  league: LeagueCreateOneWithoutTeamsInput;
  players?: PlayerCreateManyWithoutTeamInput;
}

export interface GameUpdateWithWhereUniqueWithoutPostedByInput {
  where: GameWhereUniqueInput;
  data: GameUpdateWithoutPostedByDataInput;
}

export interface PlayerCreateWithoutTeamInput {
  id?: ID_Input;
  postedBy: UserCreateOneWithoutPlayersInput;
  name: String;
  played?: Int;
  goals?: Int;
  assists?: Int;
  saves?: Int;
}

export interface GameUpdateWithoutPostedByDataInput {
  homeTeam?: TeamUpdateOneRequiredInput;
  awayTeam?: TeamUpdateOneRequiredInput;
  score?: String;
  day?: String;
  time?: String;
  videoURL?: String;
  league?: LeagueUpdateOneRequiredWithoutGamesInput;
}

export interface UserCreateWithoutPlayersInput {
  id?: ID_Input;
  name: String;
  password: String;
  email: String;
  role?: Role;
  leagues?: LeagueCreateManyWithoutPostedByInput;
  teams?: TeamCreateManyWithoutPostedByInput;
  games?: GameCreateManyWithoutPostedByInput;
}

export interface LeagueUpdateOneRequiredWithoutGamesInput {
  create?: LeagueCreateWithoutGamesInput;
  update?: LeagueUpdateWithoutGamesDataInput;
  upsert?: LeagueUpsertWithoutGamesInput;
  connect?: LeagueWhereUniqueInput;
}

export interface LeagueCreateWithoutGamesInput {
  id?: ID_Input;
  postedBy: UserCreateOneWithoutLeaguesInput;
  name: String;
  teams?: TeamCreateManyWithoutLeagueInput;
  location: String;
}

export interface LeagueUpdateWithoutGamesDataInput {
  postedBy?: UserUpdateOneRequiredWithoutLeaguesInput;
  name?: String;
  teams?: TeamUpdateManyWithoutLeagueInput;
  location?: String;
}

export interface GameCreateWithoutLeagueInput {
  id?: ID_Input;
  postedBy: UserCreateOneWithoutGamesInput;
  homeTeam: TeamCreateOneInput;
  awayTeam: TeamCreateOneInput;
  score?: String;
  day: String;
  time?: String;
  videoURL?: String;
}

export interface LeagueUpsertWithoutGamesInput {
  update: LeagueUpdateWithoutGamesDataInput;
  create: LeagueCreateWithoutGamesInput;
}

export interface UserUpdateOneRequiredWithoutGamesInput {
  create?: UserCreateWithoutGamesInput;
  update?: UserUpdateWithoutGamesDataInput;
  upsert?: UserUpsertWithoutGamesInput;
  connect?: UserWhereUniqueInput;
}

export interface GameUpsertWithWhereUniqueWithoutPostedByInput {
  where: GameWhereUniqueInput;
  update: GameUpdateWithoutPostedByDataInput;
  create: GameCreateWithoutPostedByInput;
}

export interface LeagueUpdateManyWithoutPostedByInput {
  create?:
    | LeagueCreateWithoutPostedByInput[]
    | LeagueCreateWithoutPostedByInput;
  delete?: LeagueWhereUniqueInput[] | LeagueWhereUniqueInput;
  connect?: LeagueWhereUniqueInput[] | LeagueWhereUniqueInput;
  set?: LeagueWhereUniqueInput[] | LeagueWhereUniqueInput;
  disconnect?: LeagueWhereUniqueInput[] | LeagueWhereUniqueInput;
  update?:
    | LeagueUpdateWithWhereUniqueWithoutPostedByInput[]
    | LeagueUpdateWithWhereUniqueWithoutPostedByInput;
  upsert?:
    | LeagueUpsertWithWhereUniqueWithoutPostedByInput[]
    | LeagueUpsertWithWhereUniqueWithoutPostedByInput;
  deleteMany?: LeagueScalarWhereInput[] | LeagueScalarWhereInput;
  updateMany?:
    | LeagueUpdateManyWithWhereNestedInput[]
    | LeagueUpdateManyWithWhereNestedInput;
}

export interface GameScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  score?: String;
  score_not?: String;
  score_in?: String[] | String;
  score_not_in?: String[] | String;
  score_lt?: String;
  score_lte?: String;
  score_gt?: String;
  score_gte?: String;
  score_contains?: String;
  score_not_contains?: String;
  score_starts_with?: String;
  score_not_starts_with?: String;
  score_ends_with?: String;
  score_not_ends_with?: String;
  day?: String;
  day_not?: String;
  day_in?: String[] | String;
  day_not_in?: String[] | String;
  day_lt?: String;
  day_lte?: String;
  day_gt?: String;
  day_gte?: String;
  day_contains?: String;
  day_not_contains?: String;
  day_starts_with?: String;
  day_not_starts_with?: String;
  day_ends_with?: String;
  day_not_ends_with?: String;
  time?: String;
  time_not?: String;
  time_in?: String[] | String;
  time_not_in?: String[] | String;
  time_lt?: String;
  time_lte?: String;
  time_gt?: String;
  time_gte?: String;
  time_contains?: String;
  time_not_contains?: String;
  time_starts_with?: String;
  time_not_starts_with?: String;
  time_ends_with?: String;
  time_not_ends_with?: String;
  videoURL?: String;
  videoURL_not?: String;
  videoURL_in?: String[] | String;
  videoURL_not_in?: String[] | String;
  videoURL_lt?: String;
  videoURL_lte?: String;
  videoURL_gt?: String;
  videoURL_gte?: String;
  videoURL_contains?: String;
  videoURL_not_contains?: String;
  videoURL_starts_with?: String;
  videoURL_not_starts_with?: String;
  videoURL_ends_with?: String;
  videoURL_not_ends_with?: String;
  AND?: GameScalarWhereInput[] | GameScalarWhereInput;
  OR?: GameScalarWhereInput[] | GameScalarWhereInput;
  NOT?: GameScalarWhereInput[] | GameScalarWhereInput;
}

export interface LeagueUpdateWithoutPostedByDataInput {
  name?: String;
  teams?: TeamUpdateManyWithoutLeagueInput;
  location?: String;
  games?: GameUpdateManyWithoutLeagueInput;
}

export interface GameUpdateManyWithWhereNestedInput {
  where: GameScalarWhereInput;
  data: GameUpdateManyDataInput;
}

export interface TieSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TieWhereInput;
  AND?: TieSubscriptionWhereInput[] | TieSubscriptionWhereInput;
  OR?: TieSubscriptionWhereInput[] | TieSubscriptionWhereInput;
  NOT?: TieSubscriptionWhereInput[] | TieSubscriptionWhereInput;
}

export interface GameUpdateManyDataInput {
  score?: String;
  day?: String;
  time?: String;
  videoURL?: String;
}

export type LeagueWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface UserUpsertWithoutLeaguesInput {
  update: UserUpdateWithoutLeaguesDataInput;
  create: UserCreateWithoutLeaguesInput;
}

export type LossWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GameUpdateManyWithoutLeagueInput {
  create?: GameCreateWithoutLeagueInput[] | GameCreateWithoutLeagueInput;
  delete?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  connect?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  set?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  disconnect?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  update?:
    | GameUpdateWithWhereUniqueWithoutLeagueInput[]
    | GameUpdateWithWhereUniqueWithoutLeagueInput;
  upsert?:
    | GameUpsertWithWhereUniqueWithoutLeagueInput[]
    | GameUpsertWithWhereUniqueWithoutLeagueInput;
  deleteMany?: GameScalarWhereInput[] | GameScalarWhereInput;
  updateMany?:
    | GameUpdateManyWithWhereNestedInput[]
    | GameUpdateManyWithWhereNestedInput;
}

export type PlayerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GameUpdateWithWhereUniqueWithoutLeagueInput {
  where: GameWhereUniqueInput;
  data: GameUpdateWithoutLeagueDataInput;
}

export type TeamWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface GameUpdateWithoutLeagueDataInput {
  postedBy?: UserUpdateOneRequiredWithoutGamesInput;
  homeTeam?: TeamUpdateOneRequiredInput;
  awayTeam?: TeamUpdateOneRequiredInput;
  score?: String;
  day?: String;
  time?: String;
  videoURL?: String;
}

export type TieWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GameUpsertWithWhereUniqueWithoutLeagueInput {
  where: GameWhereUniqueInput;
  update: GameUpdateWithoutLeagueDataInput;
  create: GameCreateWithoutLeagueInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface LeagueUpsertWithoutTeamsInput {
  update: LeagueUpdateWithoutTeamsDataInput;
  create: LeagueCreateWithoutTeamsInput;
}

export interface TeamUpdateManyMutationInput {
  name?: String;
}

export interface PlayerUpdateManyWithoutTeamInput {
  create?: PlayerCreateWithoutTeamInput[] | PlayerCreateWithoutTeamInput;
  delete?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  connect?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  set?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  disconnect?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  update?:
    | PlayerUpdateWithWhereUniqueWithoutTeamInput[]
    | PlayerUpdateWithWhereUniqueWithoutTeamInput;
  upsert?:
    | PlayerUpsertWithWhereUniqueWithoutTeamInput[]
    | PlayerUpsertWithWhereUniqueWithoutTeamInput;
  deleteMany?: PlayerScalarWhereInput[] | PlayerScalarWhereInput;
  updateMany?:
    | PlayerUpdateManyWithWhereNestedInput[]
    | PlayerUpdateManyWithWhereNestedInput;
}

export interface PlayerUpdateInput {
  postedBy?: UserUpdateOneRequiredWithoutPlayersInput;
  name?: String;
  played?: Int;
  goals?: Int;
  assists?: Int;
  saves?: Int;
  team?: TeamUpdateOneRequiredWithoutPlayersInput;
}

export interface PlayerUpdateWithWhereUniqueWithoutTeamInput {
  where: PlayerWhereUniqueInput;
  data: PlayerUpdateWithoutTeamDataInput;
}

export interface UserCreateWithoutGamesInput {
  id?: ID_Input;
  name: String;
  password: String;
  email: String;
  role?: Role;
  leagues?: LeagueCreateManyWithoutPostedByInput;
  teams?: TeamCreateManyWithoutPostedByInput;
  players?: PlayerCreateManyWithoutPostedByInput;
}

export interface PlayerUpdateWithoutTeamDataInput {
  postedBy?: UserUpdateOneRequiredWithoutPlayersInput;
  name?: String;
  played?: Int;
  goals?: Int;
  assists?: Int;
  saves?: Int;
}

export interface TeamCreateWithoutLeagueInput {
  id?: ID_Input;
  postedBy: UserCreateOneWithoutTeamsInput;
  name: String;
  wins?: WinCreateManyWithoutTeamInput;
  losses?: LossCreateManyWithoutTeamInput;
  ties?: TieCreateManyWithoutTeamInput;
  players?: PlayerCreateManyWithoutTeamInput;
}

export interface UserUpdateOneRequiredWithoutPlayersInput {
  create?: UserCreateWithoutPlayersInput;
  update?: UserUpdateWithoutPlayersDataInput;
  upsert?: UserUpsertWithoutPlayersInput;
  connect?: UserWhereUniqueInput;
}

export interface PlayerCreateWithoutPostedByInput {
  id?: ID_Input;
  name: String;
  played?: Int;
  goals?: Int;
  assists?: Int;
  saves?: Int;
  team: TeamCreateOneWithoutPlayersInput;
}

export interface UserUpdateWithoutPlayersDataInput {
  name?: String;
  password?: String;
  email?: String;
  role?: Role;
  leagues?: LeagueUpdateManyWithoutPostedByInput;
  teams?: TeamUpdateManyWithoutPostedByInput;
  games?: GameUpdateManyWithoutPostedByInput;
}

export interface WinCreateWithoutTeamInput {
  id?: ID_Input;
  postedBy: UserCreateOneInput;
  game: GameCreateOneInput;
}

export interface UserUpsertWithoutPlayersInput {
  update: UserUpdateWithoutPlayersDataInput;
  create: UserCreateWithoutPlayersInput;
}

export interface TeamCreateWithoutPostedByInput {
  id?: ID_Input;
  name: String;
  wins?: WinCreateManyWithoutTeamInput;
  losses?: LossCreateManyWithoutTeamInput;
  ties?: TieCreateManyWithoutTeamInput;
  league: LeagueCreateOneWithoutTeamsInput;
  players?: PlayerCreateManyWithoutTeamInput;
}

export interface PlayerUpsertWithWhereUniqueWithoutTeamInput {
  where: PlayerWhereUniqueInput;
  update: PlayerUpdateWithoutTeamDataInput;
  create: PlayerCreateWithoutTeamInput;
}

export interface TieCreateManyWithoutTeamInput {
  create?: TieCreateWithoutTeamInput[] | TieCreateWithoutTeamInput;
  connect?: TieWhereUniqueInput[] | TieWhereUniqueInput;
}

export interface PlayerScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  played?: Int;
  played_not?: Int;
  played_in?: Int[] | Int;
  played_not_in?: Int[] | Int;
  played_lt?: Int;
  played_lte?: Int;
  played_gt?: Int;
  played_gte?: Int;
  goals?: Int;
  goals_not?: Int;
  goals_in?: Int[] | Int;
  goals_not_in?: Int[] | Int;
  goals_lt?: Int;
  goals_lte?: Int;
  goals_gt?: Int;
  goals_gte?: Int;
  assists?: Int;
  assists_not?: Int;
  assists_in?: Int[] | Int;
  assists_not_in?: Int[] | Int;
  assists_lt?: Int;
  assists_lte?: Int;
  assists_gt?: Int;
  assists_gte?: Int;
  saves?: Int;
  saves_not?: Int;
  saves_in?: Int[] | Int;
  saves_not_in?: Int[] | Int;
  saves_lt?: Int;
  saves_lte?: Int;
  saves_gt?: Int;
  saves_gte?: Int;
  AND?: PlayerScalarWhereInput[] | PlayerScalarWhereInput;
  OR?: PlayerScalarWhereInput[] | PlayerScalarWhereInput;
  NOT?: PlayerScalarWhereInput[] | PlayerScalarWhereInput;
}

export interface UserCreateOneWithoutLeaguesInput {
  create?: UserCreateWithoutLeaguesInput;
  connect?: UserWhereUniqueInput;
}

export interface PlayerUpdateManyWithWhereNestedInput {
  where: PlayerScalarWhereInput;
  data: PlayerUpdateManyDataInput;
}

export interface TeamCreateOneInput {
  create?: TeamCreateInput;
  connect?: TeamWhereUniqueInput;
}

export interface PlayerUpdateManyDataInput {
  name?: String;
  played?: Int;
  goals?: Int;
  assists?: Int;
  saves?: Int;
}

export interface UserCreateOneWithoutPlayersInput {
  create?: UserCreateWithoutPlayersInput;
  connect?: UserWhereUniqueInput;
}

export interface TeamUpsertNestedInput {
  update: TeamUpdateDataInput;
  create: TeamCreateInput;
}

export interface GameCreateManyWithoutLeagueInput {
  create?: GameCreateWithoutLeagueInput[] | GameCreateWithoutLeagueInput;
  connect?: GameWhereUniqueInput[] | GameWhereUniqueInput;
}

export interface GameUpsertNestedInput {
  update: GameUpdateDataInput;
  create: GameCreateInput;
}

export interface UserUpdateWithoutGamesDataInput {
  name?: String;
  password?: String;
  email?: String;
  role?: Role;
  leagues?: LeagueUpdateManyWithoutPostedByInput;
  teams?: TeamUpdateManyWithoutPostedByInput;
  players?: PlayerUpdateManyWithoutPostedByInput;
}

export interface LossUpsertWithWhereUniqueWithoutTeamInput {
  where: LossWhereUniqueInput;
  update: LossUpdateWithoutTeamDataInput;
  create: LossCreateWithoutTeamInput;
}

export interface WinSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WinWhereInput;
  AND?: WinSubscriptionWhereInput[] | WinSubscriptionWhereInput;
  OR?: WinSubscriptionWhereInput[] | WinSubscriptionWhereInput;
  NOT?: WinSubscriptionWhereInput[] | WinSubscriptionWhereInput;
}

export interface LossScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: LossScalarWhereInput[] | LossScalarWhereInput;
  OR?: LossScalarWhereInput[] | LossScalarWhereInput;
  NOT?: LossScalarWhereInput[] | LossScalarWhereInput;
}

export interface GameSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GameWhereInput;
  AND?: GameSubscriptionWhereInput[] | GameSubscriptionWhereInput;
  OR?: GameSubscriptionWhereInput[] | GameSubscriptionWhereInput;
  NOT?: GameSubscriptionWhereInput[] | GameSubscriptionWhereInput;
}

export interface TeamUpsertWithWhereUniqueWithoutPostedByInput {
  where: TeamWhereUniqueInput;
  update: TeamUpdateWithoutPostedByDataInput;
  create: TeamCreateWithoutPostedByInput;
}

export interface TeamCreateOneWithoutWinsInput {
  create?: TeamCreateWithoutWinsInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: TeamScalarWhereInput[] | TeamScalarWhereInput;
  OR?: TeamScalarWhereInput[] | TeamScalarWhereInput;
  NOT?: TeamScalarWhereInput[] | TeamScalarWhereInput;
}

export interface TeamUpdateOneRequiredWithoutTiesInput {
  create?: TeamCreateWithoutTiesInput;
  update?: TeamUpdateWithoutTiesDataInput;
  upsert?: TeamUpsertWithoutTiesInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamUpdateManyWithWhereNestedInput {
  where: TeamScalarWhereInput;
  data: TeamUpdateManyDataInput;
}

export interface TeamUpdateInput {
  postedBy?: UserUpdateOneRequiredWithoutTeamsInput;
  name?: String;
  wins?: WinUpdateManyWithoutTeamInput;
  losses?: LossUpdateManyWithoutTeamInput;
  ties?: TieUpdateManyWithoutTeamInput;
  league?: LeagueUpdateOneRequiredWithoutTeamsInput;
  players?: PlayerUpdateManyWithoutTeamInput;
}

export interface TeamUpdateManyDataInput {
  name?: String;
}

export interface LeagueCreateWithoutPostedByInput {
  id?: ID_Input;
  name: String;
  teams?: TeamCreateManyWithoutLeagueInput;
  location: String;
  games?: GameCreateManyWithoutLeagueInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface TeamCreateWithoutPlayersInput {
  id?: ID_Input;
  postedBy: UserCreateOneWithoutTeamsInput;
  name: String;
  wins?: WinCreateManyWithoutTeamInput;
  losses?: LossCreateManyWithoutTeamInput;
  ties?: TieCreateManyWithoutTeamInput;
  league: LeagueCreateOneWithoutTeamsInput;
}

export interface WinUpsertWithWhereUniqueWithoutTeamInput {
  where: WinWhereUniqueInput;
  update: WinUpdateWithoutTeamDataInput;
  create: WinCreateWithoutTeamInput;
}

export interface LossCreateWithoutTeamInput {
  id?: ID_Input;
  postedBy: UserCreateOneInput;
  game: GameCreateOneInput;
}

export interface WinScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: WinScalarWhereInput[] | WinScalarWhereInput;
  OR?: WinScalarWhereInput[] | WinScalarWhereInput;
  NOT?: WinScalarWhereInput[] | WinScalarWhereInput;
}

export interface GameCreateManyWithoutPostedByInput {
  create?: GameCreateWithoutPostedByInput[] | GameCreateWithoutPostedByInput;
  connect?: GameWhereUniqueInput[] | GameWhereUniqueInput;
}

export interface TeamUpsertWithoutPlayersInput {
  update: TeamUpdateWithoutPlayersDataInput;
  create: TeamCreateWithoutPlayersInput;
}

export interface LeagueCreateOneWithoutGamesInput {
  create?: LeagueCreateWithoutGamesInput;
  connect?: LeagueWhereUniqueInput;
}

export interface PlayerUpsertWithWhereUniqueWithoutPostedByInput {
  where: PlayerWhereUniqueInput;
  update: PlayerUpdateWithoutPostedByDataInput;
  create: PlayerCreateWithoutPostedByInput;
}

export interface LeagueUpdateWithWhereUniqueWithoutPostedByInput {
  where: LeagueWhereUniqueInput;
  data: LeagueUpdateWithoutPostedByDataInput;
}

export interface UserUpsertWithoutTeamsInput {
  update: UserUpdateWithoutTeamsDataInput;
  create: UserCreateWithoutTeamsInput;
}

export interface TeamUpdateOneRequiredWithoutWinsInput {
  create?: TeamCreateWithoutWinsInput;
  update?: TeamUpdateWithoutWinsDataInput;
  upsert?: TeamUpsertWithoutWinsInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamUpsertWithWhereUniqueWithoutLeagueInput {
  where: TeamWhereUniqueInput;
  update: TeamUpdateWithoutLeagueDataInput;
  create: TeamCreateWithoutLeagueInput;
}

export interface TeamCreateOneWithoutTiesInput {
  create?: TeamCreateWithoutTiesInput;
  connect?: TeamWhereUniqueInput;
}

export interface LeagueUpsertWithWhereUniqueWithoutPostedByInput {
  where: LeagueWhereUniqueInput;
  update: LeagueUpdateWithoutPostedByDataInput;
  create: LeagueCreateWithoutPostedByInput;
}

export interface UserCreateWithoutTeamsInput {
  id?: ID_Input;
  name: String;
  password: String;
  email: String;
  role?: Role;
  leagues?: LeagueCreateManyWithoutPostedByInput;
  players?: PlayerCreateManyWithoutPostedByInput;
  games?: GameCreateManyWithoutPostedByInput;
}

export interface LeagueScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  location?: String;
  location_not?: String;
  location_in?: String[] | String;
  location_not_in?: String[] | String;
  location_lt?: String;
  location_lte?: String;
  location_gt?: String;
  location_gte?: String;
  location_contains?: String;
  location_not_contains?: String;
  location_starts_with?: String;
  location_not_starts_with?: String;
  location_ends_with?: String;
  location_not_ends_with?: String;
  AND?: LeagueScalarWhereInput[] | LeagueScalarWhereInput;
  OR?: LeagueScalarWhereInput[] | LeagueScalarWhereInput;
  NOT?: LeagueScalarWhereInput[] | LeagueScalarWhereInput;
}

export interface LeagueCreateOneWithoutTeamsInput {
  create?: LeagueCreateWithoutTeamsInput;
  connect?: LeagueWhereUniqueInput;
}

export interface LeagueUpdateManyWithWhereNestedInput {
  where: LeagueScalarWhereInput;
  data: LeagueUpdateManyDataInput;
}

export interface GameUpdateInput {
  postedBy?: UserUpdateOneRequiredWithoutGamesInput;
  homeTeam?: TeamUpdateOneRequiredInput;
  awayTeam?: TeamUpdateOneRequiredInput;
  score?: String;
  day?: String;
  time?: String;
  videoURL?: String;
  league?: LeagueUpdateOneRequiredWithoutGamesInput;
}

export interface LeagueUpdateManyDataInput {
  name?: String;
  location?: String;
}

export interface UserUpdateInput {
  name?: String;
  password?: String;
  email?: String;
  role?: Role;
  leagues?: LeagueUpdateManyWithoutPostedByInput;
  teams?: TeamUpdateManyWithoutPostedByInput;
  players?: PlayerUpdateManyWithoutPostedByInput;
  games?: GameUpdateManyWithoutPostedByInput;
}

export interface LeagueUpdateInput {
  postedBy?: UserUpdateOneRequiredWithoutLeaguesInput;
  name?: String;
  teams?: TeamUpdateManyWithoutLeagueInput;
  location?: String;
  games?: GameUpdateManyWithoutLeagueInput;
}

export interface LeagueUpdateManyMutationInput {
  name?: String;
  location?: String;
}

export interface GameUpdateManyMutationInput {
  score?: String;
  day?: String;
  time?: String;
  videoURL?: String;
}

export interface UserUpsertWithoutGamesInput {
  update: UserUpdateWithoutGamesDataInput;
  create: UserCreateWithoutGamesInput;
}

export interface GameCreateInput {
  id?: ID_Input;
  postedBy: UserCreateOneWithoutGamesInput;
  homeTeam: TeamCreateOneInput;
  awayTeam: TeamCreateOneInput;
  score?: String;
  day: String;
  time?: String;
  videoURL?: String;
  league: LeagueCreateOneWithoutGamesInput;
}

export interface PlayerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PlayerWhereInput;
  AND?: PlayerSubscriptionWhereInput[] | PlayerSubscriptionWhereInput;
  OR?: PlayerSubscriptionWhereInput[] | PlayerSubscriptionWhereInput;
  NOT?: PlayerSubscriptionWhereInput[] | PlayerSubscriptionWhereInput;
}

export interface PlayerCreateManyWithoutTeamInput {
  create?: PlayerCreateWithoutTeamInput[] | PlayerCreateWithoutTeamInput;
  connect?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
}

export interface UserCreateInput {
  id?: ID_Input;
  name: String;
  password: String;
  email: String;
  role?: Role;
  leagues?: LeagueCreateManyWithoutPostedByInput;
  teams?: TeamCreateManyWithoutPostedByInput;
  players?: PlayerCreateManyWithoutPostedByInput;
  games?: GameCreateManyWithoutPostedByInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface WinPreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface WinPreviousValuesPromise
  extends Promise<WinPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface WinPreviousValuesSubscription
  extends Promise<AsyncIterator<WinPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlayerConnection {
  pageInfo: PageInfo;
  edges: PlayerEdge[];
}

export interface PlayerConnectionPromise
  extends Promise<PlayerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlayerEdge>>() => T;
  aggregate: <T = AggregatePlayerPromise>() => T;
}

export interface PlayerConnectionSubscription
  extends Promise<AsyncIterator<PlayerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlayerEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlayerSubscription>() => T;
}

export interface GameConnection {
  pageInfo: PageInfo;
  edges: GameEdge[];
}

export interface GameConnectionPromise
  extends Promise<GameConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GameEdge>>() => T;
  aggregate: <T = AggregateGamePromise>() => T;
}

export interface GameConnectionSubscription
  extends Promise<AsyncIterator<GameConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GameEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGameSubscription>() => T;
}

export interface AggregateLoss {
  count: Int;
}

export interface AggregateLossPromise
  extends Promise<AggregateLoss>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLossSubscription
  extends Promise<AsyncIterator<AggregateLoss>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LossEdge {
  node: Loss;
  cursor: String;
}

export interface LossEdgePromise extends Promise<LossEdge>, Fragmentable {
  node: <T = LossPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LossEdgeSubscription
  extends Promise<AsyncIterator<LossEdge>>,
    Fragmentable {
  node: <T = LossSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Tie {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface TiePromise extends Promise<Tie>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  postedBy: <T = UserPromise>() => T;
  team: <T = TeamPromise>() => T;
  game: <T = GamePromise>() => T;
}

export interface TieSubscription
  extends Promise<AsyncIterator<Tie>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  postedBy: <T = UserSubscription>() => T;
  team: <T = TeamSubscription>() => T;
  game: <T = GameSubscription>() => T;
}

export interface LossConnection {
  pageInfo: PageInfo;
  edges: LossEdge[];
}

export interface LossConnectionPromise
  extends Promise<LossConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LossEdge>>() => T;
  aggregate: <T = AggregateLossPromise>() => T;
}

export interface LossConnectionSubscription
  extends Promise<AsyncIterator<LossConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LossEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLossSubscription>() => T;
}

export interface Win {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface WinPromise extends Promise<Win>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  postedBy: <T = UserPromise>() => T;
  team: <T = TeamPromise>() => T;
  game: <T = GamePromise>() => T;
}

export interface WinSubscription
  extends Promise<AsyncIterator<Win>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  postedBy: <T = UserSubscription>() => T;
  team: <T = TeamSubscription>() => T;
  game: <T = GameSubscription>() => T;
}

export interface AggregateLeague {
  count: Int;
}

export interface AggregateLeaguePromise
  extends Promise<AggregateLeague>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLeagueSubscription
  extends Promise<AsyncIterator<AggregateLeague>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface League {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  name: String;
  location: String;
}

export interface LeaguePromise extends Promise<League>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  postedBy: <T = UserPromise>() => T;
  name: () => Promise<String>;
  teams: <T = FragmentableArray<Team>>(args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  location: () => Promise<String>;
  games: <T = FragmentableArray<Game>>(args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LeagueSubscription
  extends Promise<AsyncIterator<League>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  postedBy: <T = UserSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  teams: <T = Promise<AsyncIterator<TeamSubscription>>>(args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  location: () => Promise<AsyncIterator<String>>;
  games: <T = Promise<AsyncIterator<GameSubscription>>>(args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LeagueEdge {
  node: League;
  cursor: String;
}

export interface LeagueEdgePromise extends Promise<LeagueEdge>, Fragmentable {
  node: <T = LeaguePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LeagueEdgeSubscription
  extends Promise<AsyncIterator<LeagueEdge>>,
    Fragmentable {
  node: <T = LeagueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  name: String;
  password: String;
  email: String;
  role: Role;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<Role>;
  leagues: <T = FragmentableArray<League>>(args?: {
    where?: LeagueWhereInput;
    orderBy?: LeagueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  teams: <T = FragmentableArray<Team>>(args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  players: <T = FragmentableArray<Player>>(args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  games: <T = FragmentableArray<Game>>(args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  leagues: <T = Promise<AsyncIterator<LeagueSubscription>>>(args?: {
    where?: LeagueWhereInput;
    orderBy?: LeagueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  teams: <T = Promise<AsyncIterator<TeamSubscription>>>(args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  players: <T = Promise<AsyncIterator<PlayerSubscription>>>(args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  games: <T = Promise<AsyncIterator<GameSubscription>>>(args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Game {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  score: String;
  day: String;
  time: String;
  videoURL: String;
}

export interface GamePromise extends Promise<Game>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  postedBy: <T = UserPromise>() => T;
  homeTeam: <T = TeamPromise>() => T;
  awayTeam: <T = TeamPromise>() => T;
  score: () => Promise<String>;
  day: () => Promise<String>;
  time: () => Promise<String>;
  videoURL: () => Promise<String>;
  league: <T = LeaguePromise>() => T;
}

export interface GameSubscription
  extends Promise<AsyncIterator<Game>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  postedBy: <T = UserSubscription>() => T;
  homeTeam: <T = TeamSubscription>() => T;
  awayTeam: <T = TeamSubscription>() => T;
  score: () => Promise<AsyncIterator<String>>;
  day: () => Promise<AsyncIterator<String>>;
  time: () => Promise<AsyncIterator<String>>;
  videoURL: () => Promise<AsyncIterator<String>>;
  league: <T = LeagueSubscription>() => T;
}

export interface WinEdge {
  node: Win;
  cursor: String;
}

export interface WinEdgePromise extends Promise<WinEdge>, Fragmentable {
  node: <T = WinPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WinEdgeSubscription
  extends Promise<AsyncIterator<WinEdge>>,
    Fragmentable {
  node: <T = WinSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GameSubscriptionPayload {
  mutation: MutationType;
  node: Game;
  updatedFields: String[];
  previousValues: GamePreviousValues;
}

export interface GameSubscriptionPayloadPromise
  extends Promise<GameSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamePreviousValuesPromise>() => T;
}

export interface GameSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GameSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GameSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamePreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GamePreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  score: String;
  day: String;
  time: String;
  videoURL: String;
}

export interface GamePreviousValuesPromise
  extends Promise<GamePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  score: () => Promise<String>;
  day: () => Promise<String>;
  time: () => Promise<String>;
  videoURL: () => Promise<String>;
}

export interface GamePreviousValuesSubscription
  extends Promise<AsyncIterator<GamePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  score: () => Promise<AsyncIterator<String>>;
  day: () => Promise<AsyncIterator<String>>;
  time: () => Promise<AsyncIterator<String>>;
  videoURL: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface LeagueConnection {
  pageInfo: PageInfo;
  edges: LeagueEdge[];
}

export interface LeagueConnectionPromise
  extends Promise<LeagueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LeagueEdge>>() => T;
  aggregate: <T = AggregateLeaguePromise>() => T;
}

export interface LeagueConnectionSubscription
  extends Promise<AsyncIterator<LeagueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LeagueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLeagueSubscription>() => T;
}

export interface AggregateTie {
  count: Int;
}

export interface AggregateTiePromise
  extends Promise<AggregateTie>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTieSubscription
  extends Promise<AsyncIterator<AggregateTie>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LeagueSubscriptionPayload {
  mutation: MutationType;
  node: League;
  updatedFields: String[];
  previousValues: LeaguePreviousValues;
}

export interface LeagueSubscriptionPayloadPromise
  extends Promise<LeagueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LeaguePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LeaguePreviousValuesPromise>() => T;
}

export interface LeagueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LeagueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LeagueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LeaguePreviousValuesSubscription>() => T;
}

export interface TieConnection {
  pageInfo: PageInfo;
  edges: TieEdge[];
}

export interface TieConnectionPromise
  extends Promise<TieConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TieEdge>>() => T;
  aggregate: <T = AggregateTiePromise>() => T;
}

export interface TieConnectionSubscription
  extends Promise<AsyncIterator<TieConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TieEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTieSubscription>() => T;
}

export interface LeaguePreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  name: String;
  location: String;
}

export interface LeaguePreviousValuesPromise
  extends Promise<LeaguePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  location: () => Promise<String>;
}

export interface LeaguePreviousValuesSubscription
  extends Promise<AsyncIterator<LeaguePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
}

export interface TeamEdge {
  node: Team;
  cursor: String;
}

export interface TeamEdgePromise extends Promise<TeamEdge>, Fragmentable {
  node: <T = TeamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TeamEdgeSubscription
  extends Promise<AsyncIterator<TeamEdge>>,
    Fragmentable {
  node: <T = TeamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGame {
  count: Int;
}

export interface AggregateGamePromise
  extends Promise<AggregateGame>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGameSubscription
  extends Promise<AsyncIterator<AggregateGame>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePlayer {
  count: Int;
}

export interface AggregatePlayerPromise
  extends Promise<AggregatePlayer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlayerSubscription
  extends Promise<AsyncIterator<AggregatePlayer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LossSubscriptionPayload {
  mutation: MutationType;
  node: Loss;
  updatedFields: String[];
  previousValues: LossPreviousValues;
}

export interface LossSubscriptionPayloadPromise
  extends Promise<LossSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LossPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LossPreviousValuesPromise>() => T;
}

export interface LossSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LossSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LossSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LossPreviousValuesSubscription>() => T;
}

export interface Player {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  name: String;
  played: Int;
  goals: Int;
  assists: Int;
  saves: Int;
}

export interface PlayerPromise extends Promise<Player>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  postedBy: <T = UserPromise>() => T;
  name: () => Promise<String>;
  played: () => Promise<Int>;
  goals: () => Promise<Int>;
  assists: () => Promise<Int>;
  saves: () => Promise<Int>;
  team: <T = TeamPromise>() => T;
}

export interface PlayerSubscription
  extends Promise<AsyncIterator<Player>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  postedBy: <T = UserSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  played: () => Promise<AsyncIterator<Int>>;
  goals: () => Promise<AsyncIterator<Int>>;
  assists: () => Promise<AsyncIterator<Int>>;
  saves: () => Promise<AsyncIterator<Int>>;
  team: <T = TeamSubscription>() => T;
}

export interface LossPreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface LossPreviousValuesPromise
  extends Promise<LossPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LossPreviousValuesSubscription
  extends Promise<AsyncIterator<LossPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Team {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  name: String;
}

export interface TeamPromise extends Promise<Team>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  postedBy: <T = UserPromise>() => T;
  name: () => Promise<String>;
  wins: <T = FragmentableArray<Win>>(args?: {
    where?: WinWhereInput;
    orderBy?: WinOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  losses: <T = FragmentableArray<Loss>>(args?: {
    where?: LossWhereInput;
    orderBy?: LossOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  ties: <T = FragmentableArray<Tie>>(args?: {
    where?: TieWhereInput;
    orderBy?: TieOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  league: <T = LeaguePromise>() => T;
  players: <T = FragmentableArray<Player>>(args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TeamSubscription
  extends Promise<AsyncIterator<Team>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  postedBy: <T = UserSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  wins: <T = Promise<AsyncIterator<WinSubscription>>>(args?: {
    where?: WinWhereInput;
    orderBy?: WinOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  losses: <T = Promise<AsyncIterator<LossSubscription>>>(args?: {
    where?: LossWhereInput;
    orderBy?: LossOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  ties: <T = Promise<AsyncIterator<TieSubscription>>>(args?: {
    where?: TieWhereInput;
    orderBy?: TieOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  league: <T = LeagueSubscription>() => T;
  players: <T = Promise<AsyncIterator<PlayerSubscription>>>(args?: {
    where?: PlayerWhereInput;
    orderBy?: PlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GameEdge {
  node: Game;
  cursor: String;
}

export interface GameEdgePromise extends Promise<GameEdge>, Fragmentable {
  node: <T = GamePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GameEdgeSubscription
  extends Promise<AsyncIterator<GameEdge>>,
    Fragmentable {
  node: <T = GameSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWin {
  count: Int;
}

export interface AggregateWinPromise
  extends Promise<AggregateWin>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWinSubscription
  extends Promise<AsyncIterator<AggregateWin>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlayerSubscriptionPayload {
  mutation: MutationType;
  node: Player;
  updatedFields: String[];
  previousValues: PlayerPreviousValues;
}

export interface PlayerSubscriptionPayloadPromise
  extends Promise<PlayerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlayerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlayerPreviousValuesPromise>() => T;
}

export interface PlayerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlayerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlayerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlayerPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PlayerPreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  name: String;
  played: Int;
  goals: Int;
  assists: Int;
  saves: Int;
}

export interface PlayerPreviousValuesPromise
  extends Promise<PlayerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  played: () => Promise<Int>;
  goals: () => Promise<Int>;
  assists: () => Promise<Int>;
  saves: () => Promise<Int>;
}

export interface PlayerPreviousValuesSubscription
  extends Promise<AsyncIterator<PlayerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  played: () => Promise<AsyncIterator<Int>>;
  goals: () => Promise<AsyncIterator<Int>>;
  assists: () => Promise<AsyncIterator<Int>>;
  saves: () => Promise<AsyncIterator<Int>>;
}

export interface TieEdge {
  node: Tie;
  cursor: String;
}

export interface TieEdgePromise extends Promise<TieEdge>, Fragmentable {
  node: <T = TiePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TieEdgeSubscription
  extends Promise<AsyncIterator<TieEdge>>,
    Fragmentable {
  node: <T = TieSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface TeamConnection {
  pageInfo: PageInfo;
  edges: TeamEdge[];
}

export interface TeamConnectionPromise
  extends Promise<TeamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TeamEdge>>() => T;
  aggregate: <T = AggregateTeamPromise>() => T;
}

export interface TeamConnectionSubscription
  extends Promise<AsyncIterator<TeamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TeamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTeamSubscription>() => T;
}

export interface TeamSubscriptionPayload {
  mutation: MutationType;
  node: Team;
  updatedFields: String[];
  previousValues: TeamPreviousValues;
}

export interface TeamSubscriptionPayloadPromise
  extends Promise<TeamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TeamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TeamPreviousValuesPromise>() => T;
}

export interface TeamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TeamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TeamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TeamPreviousValuesSubscription>() => T;
}

export interface Loss {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface LossPromise extends Promise<Loss>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  postedBy: <T = UserPromise>() => T;
  team: <T = TeamPromise>() => T;
  game: <T = GamePromise>() => T;
}

export interface LossSubscription
  extends Promise<AsyncIterator<Loss>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  postedBy: <T = UserSubscription>() => T;
  team: <T = TeamSubscription>() => T;
  game: <T = GameSubscription>() => T;
}

export interface WinConnection {
  pageInfo: PageInfo;
  edges: WinEdge[];
}

export interface WinConnectionPromise
  extends Promise<WinConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WinEdge>>() => T;
  aggregate: <T = AggregateWinPromise>() => T;
}

export interface WinConnectionSubscription
  extends Promise<AsyncIterator<WinConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WinEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWinSubscription>() => T;
}

export interface TiePreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface TiePreviousValuesPromise
  extends Promise<TiePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TiePreviousValuesSubscription
  extends Promise<AsyncIterator<TiePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TieSubscriptionPayload {
  mutation: MutationType;
  node: Tie;
  updatedFields: String[];
  previousValues: TiePreviousValues;
}

export interface TieSubscriptionPayloadPromise
  extends Promise<TieSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TiePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TiePreviousValuesPromise>() => T;
}

export interface TieSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TieSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TieSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TiePreviousValuesSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface TeamPreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  name: String;
}

export interface TeamPreviousValuesPromise
  extends Promise<TeamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface TeamPreviousValuesSubscription
  extends Promise<AsyncIterator<TeamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  name: String;
  password: String;
  email: String;
  role: Role;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<Role>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
}

export interface WinSubscriptionPayload {
  mutation: MutationType;
  node: Win;
  updatedFields: String[];
  previousValues: WinPreviousValues;
}

export interface WinSubscriptionPayloadPromise
  extends Promise<WinSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WinPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WinPreviousValuesPromise>() => T;
}

export interface WinSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WinSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WinSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WinPreviousValuesSubscription>() => T;
}

export interface PlayerEdge {
  node: Player;
  cursor: String;
}

export interface PlayerEdgePromise extends Promise<PlayerEdge>, Fragmentable {
  node: <T = PlayerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlayerEdgeSubscription
  extends Promise<AsyncIterator<PlayerEdge>>,
    Fragmentable {
  node: <T = PlayerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTeam {
  count: Int;
}

export interface AggregateTeamPromise
  extends Promise<AggregateTeam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTeamSubscription
  extends Promise<AsyncIterator<AggregateTeam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "League",
    embedded: false
  },
  {
    name: "Team",
    embedded: false
  },
  {
    name: "Player",
    embedded: false
  },
  {
    name: "Win",
    embedded: false
  },
  {
    name: "Loss",
    embedded: false
  },
  {
    name: "Tie",
    embedded: false
  },
  {
    name: "Game",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
